\documentclass[10pt]{article}

% =========================================================================
% document style changes
% =========================================================================

\usepackage{amsmath}                    % AMS math packages
\usepackage{amssymb}                    %
\usepackage[]{graphpap}
\usepackage[T1]{fontenc}                % for \mathrm{}
\usepackage{courier}                    % for \texttt{}
\usepackage{bbm}                        % for \mathbbm{1} (indicator function)
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}

%\setlength{\parskip}{\baselineskip}     % skip line following paragraphs
\setlength{\parskip}{0.0in}
\setlength{\parindent}{0.3in}             % Control margins and amount of text
\setlength{\topmargin}{-0.8in}
\setlength{\oddsidemargin}{-.15in}       % changed from {-.15in}
\setlength{\textheight}{9.5in}
\setlength{\textwidth}{6.8in}
\pagestyle{empty}                       % No page numbers

\newcommand{\spc}{\vspace{0.25in}}      % Shortcut commands
\newcommand{\ds}{\displaystyle}         %\newcommand{\ds}[1]{\displaystyle{#1}}
\newcommand{\ra}{\rightarrow}

\begin{document}                        % This is where the document begins

{\LARGE\bf
\begin{tabbing}
\hspace{2.8in} \= \hspace{1.3in} \= \hspace{1.2in} \= \\

%=========    Heading   ==================================================
CS 399 \> PA4 \> Bill Chickering (bchick)\\
\normalsize Jan 18, 2014 \> \> Jamie Irvine (jirvine)
% =========================================================================
\end{tabbing}
}
\vspace{.4in}

The abstract goes here. . . . 
Blah blah blah.  Blah blah blah.  Blah blah blah.  Blah blah blah.  Blah blah
blah.  Blah blah blah.  Blah blah blah.  Blah blah blah.  Blah blah blah.  Blah
blah blah.  Blah blah blah.  Blah blah blah.  Blah blah Blah blah blah.  Blah
blah blah.  Blah blah blah.  Blah blah blah.  Blah blah Blah blah blah.  Blah
blah blah.  Blah blah blah.  Blah blah blah.  Blah blah Blah blah blah.  Blah
blah blah.  Blah blah blah.  Blah blah blah.  Blah blah Blah blah blah.  Blah
blah blah.  Blah blah blah.  Blah blah blah.  Blah blah Blah blah blah.  Blah
blah blah.  Blah blah blah.  Blah blah blah.  Blah blah blah.  Blah blah blah.
Blah blah blah.  Blah blah blah.  blah.  Blah blah blah.  Blah blah blah.  Blah
blah blah.  blah.  Blah blah blah.  Blah blah blah.  Blah blah blah.  blah.
Blah blah blah.  Blah blah blah.  Blah blah blah.  blah.  Blah blah blah.  Blah
blah blah.  Blah blah blah.  blah.  Blah blah blah.  Blah blah blah.  Blah blah
blah.

\section*{Vision}

Shopping for lifestyle items like apparel, shoes, glasses, watches, etc. calls
for a distinct user experience. The shopper often has a fuzzy idea of what they
want--Emma wants a black party dress or Paul wants printed T-shirts--so they'd
like to peruse many similar items before deciding what to purchase. Today, it's
difficult to achieve this without having 1) a huge product catalog 2) an
excellent search engine 3) an exceptionally well articulated query. Certainly
(1) exists. Arguably (2) exists. But (3) is an onerous proposition. Instead,
one typically wades through a large number of heterogenous items hoping to find
something they like.

We're debating the details of the user interface, but the shopping app we want
on our phones would resemble the following. You begin by either entering a
query or clicking on a highlighted item. You are then shown an item. If you
like the item and want to see more like it you swipe it to the right. If you
don't like it, you swipe it to the left. If you really like it, you swipe it
down into your cart/list. You can swipe through items quickly--less than a
second per item. As you shop, the system learns in real time about your likes
and dislikes, showing you items you like with increasing frequency. At any
time, you can toggle between your search, your cart/list, or even the lists of
everything you liked or disliked. Click any item anywhere, and you see product
details along with an option to buy. Lists of items can be posted on Pinterest,
Tumblr, Facebook, or emailed to yourself or a friend. Or save a list for later
and continue a shopping session at any time.

We believe a critical ingredient to maximal user-engagement is rapid feedback
and responsiveness. People need less than a second or two to decide whether
they're interested in a pair shoes. And every time a user indicates interest or
disinterest in an item the system learns about the user's immediate desires and
is therefore better equipped to identify desirable items. Meanwhile, the system
can leverage user-sessions in aggregate to learn about item popularity and
item-item associations.  We believe this last idea is key. Learning item-item
associations from user activity is what our CS 341 work was all about. In that
project, we combined aggregated user activity along with a particular user's
click history to improve search results. The app described here would work
similarly. Importantly, however, this app idea attempts to address a data
sparsity issue by creating a user interface that by its nature will collect far
more user activity than a traditional search engine.

\section*{Implementation Ideas}

\section*{Experiment}
Unfortunately, we do not have user data on which to test our methods, since the system
has never been used before. Instead, we will simulate user behavior to get a rough
estimate of performance. To do this, we make the following assumptions:

\begin{enumerate}
\item There are a number of universal hidden features that describe each product.
These features could be something as tangible as color or as intangible as
`hipness'. Note that like latent topics, these features need not be
representable by an explicit, expressible concept.

\item Each user has a preference for products based on these hidden features. For
instance, a user could care a lot that a product is `hip', not care
at all what color it is, and have a mild preference for slim-fitting products,
assuming these are all hidden features of products.
\end{enumerate}

For testing, we simplify the model by assuming that there is only one hidden
feature. We model this as color. Since the learning algorithm is blind to color
data, this should be as difficult to determine as a less tangible feature, such
as style, but color is easier for us to use, since it is metadata that we
have about each product. Next, we create a number of fake users, defined by their color
preferences. These preferences are modeled as multinomial distributions. For instance, if
there are only the three colors red, white, and blue, a user could care deeply
that their product is red by having a (1, 0, 0) distribution over those colors.
Or, if the user doesn't care what color their product is, their distribution
would be (0.33, 0.33, 0.33). 

We can then construct a number of users with different distributions, using an
arbitrary Dirichlet distribution or our creation. This way, we can model the
phenomenon that preferences are not uniform; many users have the same style
preferences as each other and some styles are less popular than others.

With this model, we can construct a number of fake users with different
preference distributions. Based on these distributions, we can
probabilistically choose which items each user likes and then simulate their
interaction with the system. Then we can train the system on a number of fake
users to learn from their behavior. For testing, we then introduce new fake users,
and measure how well the system can predict the underlying color dtistributions of
the users. We will aim to increase the accuracy of the predicted distributions and
reduce the number of shown products needed to learn it.

\end{document}
